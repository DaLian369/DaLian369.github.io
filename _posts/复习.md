复习

## 数据库

**1.数据库范式**

第一范式：数据库表的每一列都是不可分割的原子数据项。

第二范式：在1NF的基础上，非码属性必须完全依赖于候选码。

第三范式：在2NF的基础上，任何非主属性不依赖于其他非主属性（消除传递依赖）。

**2.事务的隔离级别**

Read uncommitted：一个事务可以读取到另一个事务未提交的数据。会发生 脏读。

Read committed：一个事务要等另一个事务提交后才能读取数据。会发生 不可重复读。

Repeatable read：在事务开启后，不再允许修改操作。会发生 幻读

Serializable ：最高级别，事务串行化顺序执行。

**3.事务的ACID**

A：原子性，C：一致性，I：隔离性，D：持久性。

**4.索引**

​	加速查询的数据结构。

**索引类型：**

​	普通索引、组合索引、唯一索引、主键索引、全文索引。

​	联合索引：(a,b,c) 先查找a，找到匹配的后再查找b，依次查找。

​	mysql有最左匹配原则，如果存在范围索引，那么范围列后面的列无法用到索引。

*参考文章：*<https://blog.csdn.net/u013164931/article/details/82386555>

*参考文章：*<https://blog.csdn.net/aa1215018028/article/details/80982208>

​		   <https://www.cnblogs.com/tangchuanyang/p/6013151.html>

**聚簇索引和非聚簇索引**

聚簇索引：将数据存储和索引放到了一块，找到索引也就找到了数据，一个表仅有一个聚簇索引。

非聚簇索引：将数据存储与索引结构分开，索引结构的叶子节点指向了数据的对应行。

​	myisam通过key_buffer把索引先缓存到内存中，当需要通过索引访问数据时，在内存中直接搜索索引，然后通过索引找到磁盘响应数据，这也是为什么索引不在key_buffer命中时，速度慢的原因。

*参考文章：*<https://www.jianshu.com/p/fa8192853184>

**索引常见数据结构**

顺序查找，时间复杂度为O(n)

二叉树查找，时间复杂度为O(logn)

hash索引，不能满足范围查找

B-Tree：

​	结构：B-Tree每个节点都是一个二维数组：[key, data]，所有节点都可以存储数据。key为索引key，data为索引之外的数据。

​	检索原理：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或未找到节点返回null指针。

​	缺点：1.插入删除数据会破坏B-Tree的性质，因此在插入删除时，需要对树j进行分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。 2.区间查找可能需要返回上层节点重复遍历，IO操作繁琐。

B+Tree：

​	非叶子节点不存储data，之存储索引key，只有叶子节点存储data。

​	Mysql中的B+Tree：在经典的B+Tree的基础上做了优化，增加了顺序访问指针。在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree，提高了区间访问性能。

*参考文章：*<https://www.jianshu.com/p/486a514b0ded>

**底层结构：**

​	B树或B+树，因为B+树很适合文件系统查找。使用磁盘I/O次数评价索引结构的优劣，根据B-树的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙的利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。

*参考文章：*<https://www.cnblogs.com/boothsun/p/8970952.html>

**创建索引**

```CREATE INDEX indexName ON mytable(username(length)); ```

**修改表结构(添加索引)**

```ALTER table tableName ADD INDEX indexName(columnName);```

**创建表时直接指定**

```CREATE TABLE mytable(  
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```

**删除索引**

```DROP INDEX [indexName] ON mytable;```

**表示唯一**：UNIQUE

**显示索引信息**

通过添加 \G 来格式化输出信息。

```SHOW INDEX FROM table_name; \G```

**5.SQL优化**

核心：怎么合理创建索引、怎么使用索引、索引失效、合理创建表字段

具体：

​	(1) 在子查询中慎重使用IN或者NOT IN语句，使用where (NOT) exists的效果要好的多或用join代替，小表关联大表。（索引失效）

​	(2) 对查询进行优化，要尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。（怎么创建索引）

​	(3) 最好不要给数据库留NULL，尽可能的使用NOT NULL填充数据库。（合理创建表字段）

​	(4) 尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。（索引失效）

​	(5) 尽量避免在where子句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。（索引失效）

​	(6) 注意最左前缀匹配原子。（索引失效）

​	

**6.分库分表**

**垂直切分**

​	垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库中。

​	垂直分表是基于数据库表中的“列”进行的，某个表字段过多，可以新建一张扩展表，将不常用或字段长度较大的字段拆分出去到扩展表中。通过“大表拆小表”，便于开发与维护，也能避免跨页问题，Mysql底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能够加载更多的数据，命中率高，减少了磁盘I/O，从而提升了数据库性能。

**水平切分**

​	库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一表按不同的条件分散到多个数据库或多个表中，每个表只包含一部分数据，从而使单个表的数据量变小。

​	库内分表只解决了单一表数据过大的问题，但没有将表分布到不同机器的库上，因此对减轻Mysql数据库的压力来说，帮助不是很大。大家还是竞争同一个物理机的CPU、内存、网络、IO，最好是通过分库分表解决。

分库分表带来的问题：

​	事务一致性问题，跨节点关联查询join问题，跨节点分页、排序、函数问题，全局主键避重问题，数据迁移、扩容问题。

**分库分表策略**

​	Hash取模、范围分片、地理分片、时间分片。

**分布式事务问题**

​	跨库join的问题、横向扩容问题、结果集合并、排序的问题。

**使用分库分表中间件**

​	

*参考文章：*<https://www.cnblogs.com/butterfly100/p/9034281.html>

**7.MySQL主从复制、读写分离**

​	DQL数据查询语言、DML数据操纵语言、DDL数据定义语言、数据控制语言DCL

​	mysql从3.23版本开始提供复制功能，复制是将主库的DDL和DML操作通过二进制日志传递到复制服务器上，然后从库对这些日志重新执行，从而使得主库和从库保持数据一致。

复制原理：

​	(1) 首先MySQL主库在事务提交时会把数据库变更作为事件Events记录在二进制binlog中；mysql主库上的sys_binlog控制binlog日志刷新到磁盘。

​	(2) 主库推送二进制文件binlog中的事件到从库的中继日志relay log，之后从库根据中继日志重做数据库变更操作。通过逻辑复制，以此来达到数据一致。

​	MySQL通过3个线程来完成主从库之间的数据复制：其中BinLog Dump线程跑在主库上，I/O线程和SQL线程跑在从库上。当从库启动复制(start slave)时，首先创建I/O线程连接主库，主库随后创建BinLog Dump线程读取数据库事件并发给I/O线程，I/O线程获取到数据库事件更新到从库的中继日志Realy log中去，之后从库上的SQL线程读取中继relay log中更新的数据库事件并应用。

**8.数据库 like**

sql语句中利用like实现模糊查询，%匹配0或多个字符，_匹配单一字符。

**10.表、视图、索引、存储过程、函数**

表是由字段、关系等描述信息组成，是数据库的基础。

视图是虚拟表，本质是针对表的SQL子查询。

索引用来快速查询特定记录，为了提高查询效率而构建的。

存储过程为了完成特定功能的SQL语句集。

## 操作系统

**进程与线程的区别**

​	进程是资源分配的基本单位，它是程序执行的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正执行。

​	线程是程序执行的最小单位，是CPU调度和分派的基本单位。

​	一个进程可以由多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。

区别和优劣：

​	进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程要小的多。

​	线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。不过处理同步与互斥是编写多线程程序的难点。

​	但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也就死掉了，而一个进程死掉并不会对另一个进程造成影响，因为进程有自己独立的地址空间。

**进程通信(IPC)的方式**

​	IPC的方式通常有管道(无名管道、命名管道FIFO)、消息队列、信号量、共享内存、Socket和Stream等，其中Socket和Stream支持不同主机上的两个进程IPC。

管道：速度慢，容量有限，只有父子进程能通讯。

FIFO：任何进程间都能通讯，但速度慢。

消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。

信号量：不能传递复杂消息，只能用来同步。

共享内存区：能够很容易控制容量，速度快、但要保持同步。

*参考文章：*<https://www.cnblogs.com/zgq0/p/8780893.html>

**进程之间如何保证同步**

互斥量、信号量、事件

**进程调度策略**

先来先服务：每次调度都从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。

短进程优先调度算法：从就绪队列中选出一个估计运行时间最短的进程。

时间片轮转法：系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。当时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾。然后，再把处理机分配给就绪队列中新的队首进程，如此重复。

**磁盘调度**

先来先服务：按访问请求到达的先后次序服务。

最短寻道时间优先：优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先。

扫描(电梯)算法：当有访问请求时，磁头按一个方向移动，在移动过程中遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描，否则改变移动方向，并为经过的访问请求服务，如此反复。

循环扫描算法：选择一个方向，单向循环扫描。

**页面置换策略**

FIFO页置换：选择最旧的页进行置换。通过一个队列来管理内存中的所有页面。

最优置换：置换最长时间不适用的页，预测其未来经过多长时间才被使用。可能10、100或1000次才使用一次。

最近最少使用算法：最优置换和FIFO的关键区别在于，FIFO使用的是页调入时间，最优置换使用的是页将来使用时间。将使用离过去最近作为不远将来的近似，那么可置换最长时间没有使用的页。可以用计数器、栈实现。

**死锁**

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。

产生条件：互斥条件、请求与保持条件、不剥夺条件、环路等待条件。

解决方法：死锁预防、死锁避免、死锁的检测和解除。

## Java

**HashMap、Hashtable、ConcurrentHashMap**

HashMap：

​	初始大小16，每次扩容为2倍，负载因子0.75，允许键值为null，非线程安全。

​	1.8版本之前是位桶+链表，1.8之后时位桶+链表/红黑树，这样他的put操作的时候就需要判断链表还是树，插入后需不需要转化成树。另外1.8之前底层使用的是一个Entry数组，1.8改为了Node。

​	另外一个就是扩容机制，1.7在resize的时候首先建两倍大小的数组，遍历旧数组的每个元素，直接重新计算新的索引位置，然后头插法往拉链里填充。1.8之后会把链表上的键值按hash值分为lo和hi两串，lo串的新索引与原位置相同，hi串的新索引位置为 原位置+oldCap。

HashTable：

​	初始大小为11，每次扩容为2倍+1，负载因子0.75，不允许键值为null，线程安全。

ConcurrentHashMap：

​	与HashMap相差不大，区别是核心输入如value、链表等都是volatile修饰的，保证了获取时的可见性。其主要有三个实体类：ConcurrentHashMap(整个Hash表)，Segment(桶)，HashEntry(节点)，使用了分段锁。

优化：可以在创建HashMap前预估其大小，尽量减少扩容带来的性能损耗。

HashTable和ConcurrentHashMap参考文章二。

HashMap为何不是线程安全？

​	HashMap在插入元素过多的时候需要进行Resize，Hashmap的Resize包括扩容和ReHash两个步骤，ReHash在并发情况下可能会形成链表环，在调用get的时候就会发生死循环。参考文章3。

*参考文章：*<https://www.cnblogs.com/fsychen/p/9361858.html>

​		   https://blog.csdn.net/liuzhengkang/article/details/2916620

 		  <https://blog.csdn.net/wufaliang003/article/details/80219296>

**hashcode和equals作用**

​	hashCode会返回对象的一个哈希值。

​	equals会比较对象的hashCode。

​	如果不重写这两个方法，子类都将直接继承Object的两个方法，即比较对象的地址。而我们希望的一般是比较内容，所以需要重写。

**==和equals**

​	==专门用来比较两个基本类型的数据或两个引用变量是否相等。

​	equals用来比较两个独立对象的内容是否相同。

**线程顺序执行**

实现：

​	(1) 使用线程的join方法

​	(2) 使用主线程的join方法

​	join()：是Thread的方法，作用是调用线程需等待该join()线程执行完成后，才能继续向下运行。

应用场景：当一个线程必须等待另一个线程执行完毕时才能使用join方法。

```java

public class ThreadJoin {
	public static void main(String[] args) {
		Thread thread1 = new Thread(new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				System.out.println("产品经理规划新需求");
			}
		});
		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				try {
					thread1.join();
					System.out.println("开发人员开发新需求功能");
				}catch(Exception e) {
					System.out.println(e);
				}
			}
		});
		Thread thread3 = new Thread(new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				try {
					thread2.join();
					System.out.println("测试人员测试新功能");
				}catch(Exception e) {
					System.out.println(e);
				}
			}
		});
		thread3.start();
		thread2.start();
		thread1.start();
	}
}
```

在主线程中使用join来实现对线程的阻塞。

```java

public class ThreadJoin {
	public static void main(String[] args) throws InterruptedException {
		Thread thread1 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("产品经理规划新需求");
			}
		});
		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("开发人员开发新需求功能");
			}
		});
		Thread thread3 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("测试人员测试新功能");
			}
		});
		System.out.println(1);
		thread1.start();
		System.out.println(2);
		thread1.join();
		System.out.println(3);
		thread2.start();
		System.out.println(4);
		thread2.join();
		System.out.println(5);
		thread3.start();
	}
}
```

**线程状态**

​	NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED

**构建多线程的方式**

​	(1) 继承Thread类

​	(2) 实现Runnable接口

​	(3) 实现Callable接口

​	(4) 线程池

*参考文章：*<https://www.cnblogs.com/zhou-test/p/9811771.html>

**线程池**

​	如果通过集成Thread类和实现Runnable接口创建线程，如果线程数量多的话，频繁的创建和销毁会大大浪费时间和效率，更浪费内存！线程池可以用来管理线程，使线程重复使用。

ThreadPoolExecutor 参数：

​	corePoolSize：核心线程池的大小。

​	maximunPoolSize：线程池能创建最大的线程数量。

​	keepAliveTime：非核心线程能够空闲的最长时间，超过时间，线程终止。

​	unit：时间单位，和keepAliveTime配合使用。

​	workQueue：缓存队列，用来存放等待被执行的任务。

​	threadFactory：线程工厂，用来创建线程，有三种。

​	handler：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，有四种。

线程池状态：

​	RUNNING、SHUTDOWN、STOP、TERMINATED

*参考文章：*<https://www.cnblogs.com/zzuli/p/9386463.html>

**JDK和JRE的区别**

​	JRE是java运行时环境，包含了java虚拟机、java基础类库。是使用java语言编写的程序运行所需要的软件环境，还有所有的Java类库的class文件，都在lib目录下，并且都打包成了jar。

​	JDK是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java调试和分析的工具软件。

**Java中IO框架的设计模式**

​	装饰模式和适配器模式。

*参考文章：*<https://www.cnblogs.com/wxgblogs/p/5649933.html>

**消息队列**

使用场景：当不需要立即获得结果，但是并发量有需要进行控制的时候，就需要使用MQ，Message Queue。

四个场景：

​	应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败，导致整个过程失败。

​	比如：上传图片系统，人脸识别系统耦合。

​	异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间。

​	比如：用户注册，邮件和短信并行发送。

​	流量削峰：应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况。

​	比如：秒杀系统，后入队列的用户无法秒杀到商品，这些请求直接被抛弃，返回活动结束或商品已售完信息

消息队列有RabbitMQ，部分数据库Redis、Mysql也可以实现消息队列功能。

两种模式：

​	点对点模式：消息队列、生产者、消费者

​	发布/订阅模式：角色主题、发布者、订阅者

*参考文章：*<https://www.cnblogs.com/javalyy/p/8856731.html>

**Spring AOP**

**IoC，控制反转：**

​	是一种设计思想，就是将原来在程序中手动创建对象的控制权交由Spring框架来管理。Ioc容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map(key,value)，Map中存放的是各种对象。

​	IoC容器就像一个工厂，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象时如何被创建出来的。这样做大大增加了项目的可维护性且降低了开发难度。**IoC最大的意义在于解耦合。**

​	实现：① 使用XML配置的方式实现IOC   ②使用Spring注解配置IOC

**AOP：**

​	面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

连接点：程序执行的某个特定位置。

切点：一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。相当于查询条件、匹配方法。

增强：增强是织入到目标类连接点上的一段程序代码。

​	前置增强@Before，后置增强@After，返回增强@AfterReturning，异常增强@AfterThrowing

​	环绕增强@Around

引介：引介是一种特殊的增强，它为类添加一些属性和方法。

织入：将增强添加到目标类具体连接点上的过程。AOP有三种织入方式：①编译期织入②装载期织入③运行时织入

切面：切面是由切点和增强组成的。

*参考文章：*<https://blog.csdn.net/deniro_li/article/details/80708210>

**核心原理：使用JDK动态代理和cglib动态代理技术来实现的。**

​	(1) JDK动态代理：通过实现InvocationHandlet接口，并重写里面的invoke方法，通过proxy类指定classLoader和一组interfaces来创建动态代理。

​	(2) cglib的动态代理：CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。

*参考文章：*<https://blog.csdn.net/reallycold/article/details/82144454>

**静态代理和动态代理**

​	代理模式的目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。

按代理的创建时期，代理类可分为2类：

​	静态代理：由程序员创建代理类或特定工具自动生成源代码在对其编译。在程序运行前代理类的.class文件就已经存在了。

​	如果代理的方法很多，势必要为每一种方法都进行代理。或者，如果增加一个方法，除了实现类需要实现这个方法外，所有的代理类也要实现此方法，增加了代码的维护成本。需使用动态代理解决。

​	动态代理：动态代理类的源码在程序运行时运用反射机制动态生成，代理类和委托类的关系是运行时确定的

*参考文章：*https://blog.csdn.net/yinni11/article/details/80217241>

**SpingMVC工作原理**

​	1.客户端发送请求，直接请求到前端控制器。

​	2.前端控制器根据请求信息调用处理器映射器，解析请求对应的处理器。

​	3.解析到对应的处理器后，由处理器适配器处理。

​	4.处理器适配器会调用真正的处理器开始处理请求，并处理相应的业务逻辑。

​	5.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View

​	6.视图解析器会根据逻辑View找到实际的View。

​	7.前端控制器把返回的Model传给View进行视图渲染。

​	8.把View返回给请求者。

**MyBatis和Hibernate比较**

​	Hibernate对数据库结构提供了较为完整的封装。

​	MyBatis主要着力点在于pojo与SQL之间的映射关系。

1.两者最大的区别：

​	针对简单逻辑，Hibernate和MyBatis都有相应的代码生成工具，可以生成简单基本的DAO层方法。

​	针对高级查询，MyBatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。

2.开发难度

3.sql书写

4.数据库扩展性

5.缓存机制

总结：

​	MyBatis：小巧、方便、高校、简单、直接、半自动

​	Hibernate：强大、方便、高校、复杂、绕弯子、全自动

*参考文章：*<https://blog.csdn.net/qq_41378597/article/details/88070335>

**MyBatis一级缓存和二级缓存**

​	mybatis默认开启一级缓存，只是相当于同一个SqlSession而言的，一级缓存的生命周期，怎么判断两次查询是相同查询。

​	mybatis二级缓存是Application级别的，可以提高对数据库查询的效率，以提高应用的性能。

​	开启二级缓存，需要pojo必须是可序列化的，也就是必须实现Serializable接口，并且在映射文件XML文件里配置就可以开启缓存了。

*参考文章：*<https://www.cnblogs.com/happyflyingpig/p/7739749.html>

**GC**

判断垃圾算法：

​	引用计数器，某个对象每加一次引用，计数器+1，当计数器为0时，即可清理。缺陷：对象引用成环。

​	可达性分析法：通过"GC Roots"对象作为起始点，从这些点开始向下搜索，搜索走过的路径成为引用链，当一个对象与任何GC Roots对象相连时，则证明对象需要回收。

GC Roots对象：

​	虚拟机栈中引用的对象。

​	方法区中类静态属性引用的对象。

​	方法区中常量引用的对象。

​	本地方法栈中JNI引用的对象。

垃圾回收算法：

​	标记-清除，标记-整理，复制算法、分代收集算法。

**JVM内存结构**

​	有5大内存区域，线程独占的有虚拟机栈、本地方法栈、程序计数器，共享的有方法区和堆。

​	栈内存有一个特点是数据共享，i=1,j=1，i和j会执行同一内存区域。

​	堆内存没有数据共享。

## 计算机网络

HTTP请求首部、HTTP响应首部、IPV6的合法性

请求报文：

​	请求行：由请求方法字段、URL字段和HTTP协议版本3个字段组成。

​	请求头部、空行、请求数据

响应报文：

​	响应行、响应头、响应体

**HTTP**

​	超文本传输协议，它通常运行再TCP上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。明文传输，默认端口是80。

**HTTPS**

​	超文本安全传输协议，它是在HTTP和TCP之间加了一个安全套接字层SSL协议，SSL依靠证书来验证服务器的身份。具有安全的ssl加密传输协议，默认端口是443。

**HTTP缓存机制和原理**

强制缓存：

​	如果缓存里有缓存数据且未失效，直接返回；否则重新请求服务器，返回数据。

对比缓存：

​	首先从缓存里请求到数据的标识，然后发送给服务器，判断标识是否失效。

​	若未效，通知客户端未失效，然后从缓存里请求数据。

​	若失效，返回最新数据和缓存规则，将数据和缓存规则存入缓存系统。

Cache-Control：可以用来设置缓存。

*参考文章：*<https://www.cnblogs.com/chenqf/p/6386163.html>

**对称与非对称加密算法**

对称加密算法

​	指加密和解密使用相同密钥的算法。对称加密算法用来对敏感数据等信息进行加密，常用的算法有DES、3DES、AES、DESX、Blowfish、RC4、RC5、RC6

非对称加密算法

​	指加密和解密使用不同秘钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方则用自己的私钥解密。常见的非对称加密算法有：RSA、DSA、ECC、EI Gamal、Diffie-Hellam等。

**网页服务单进程多线程好还是多进程单线程好？**

​	资源、稳定性、响应速度

​	单进程多线程，响应速度快，但不稳定，一个线程死了，整个进程都会挂掉。

​	多进程单线程，稳定性好，占用资源多，响应速度不如单进程快。

**直播业务用什么？改进UDP**

​	进行压缩传输，在客户端解码。



## 数据结构

循环队列：

​	队满：（Q.rear+1）%MAXQSIZE=Q.front

​	对空：q.front=q.rear

完全二叉树：

​	节点总数n = n0 + n1 + n2 （入度为0即叶子，入度为1，入度为2节点）=2^h-1。h为深度。

​	整理有 n0 = n/2;  n为奇数时向上取整，n为偶数时向下取整。

**B-树和B+树**

B-树：多路平衡搜索树

​	 根节点至少两个子节点；

​	 每个中间节点都包含k-1个元素和k个孩子，其中m/2 <= k <=m；

​	 每一个叶子节点都包含k-1个元素，其中m/2 <=k <= m；

​	 所有叶子节点位于同一层；

​	 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分。

​	 关键字集合分布在整棵树中；

​	 任何一个关键字出现且只出现在一个节点中；

​	 搜索有可能在非叶子节点结束；

B+树：B-树的一种变体，拥有更高的查询性能。

​	1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

​	2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

​	3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

*参考文章：*<https://blog.csdn.net/qq_35571554/article/details/82759668>

## 算法

![](F:\desk\md\图片\排序算法.png)

*参考文章：*<https://blog.csdn.net/yuxin6866/article/details/52771739>

## 项目经验

钱的数据类型：BigDecimal

**etcd前端：**

​	使用了国际化插件vue-i18n，利用npm建立依赖。然后首先创建了一个i18n实例对象，方便全局调用。通过一个事件来进行语言的选择，可以选择简体中文、繁体中文和英文。然后就是自定义语言包，在html里进行渲染。

​	跨域问题的出现是因为浏览器的同源策略，官方描述就是同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。解决办法是首先设置后端可以接受option请求，然后在返回响应的时候设置带有“Access-Control"访问控制的响应头。接受option请求，是因为复杂请求在正式通信之前，会增加一次HTTP查询请求，来进行预检。如果不设置option请求，便将不会出现400错误。

**PE癫痫预测系统**

​	WebSocket

**药品存销信息管理系统**

​	数据库设计，mybatis使用了二级缓存，提高了数据库查询的效率，并且开了一台虚拟机，本地和虚拟机上分别创建了一个数据库，本地用来写，虚拟机上用来读。主要是在访问数据库前加了一层切面进行判断，如果是要读就让它访问虚拟机数据库，如果是写，就访问本地数据库。

​	乱码问题，mysql的编码方式和前端页面的乱码。



## 面经

**1.如何构建互联网高性能WEB系统**

(1) 缓存

​	DNS缓存、数据库缓存、分布式缓存

(2) 拆分

​	业务拆分、数据库拆分

(3) 异步

​	网络异步、磁盘异步、使用消息

*参考文章：*<https://blog.csdn.net/cxh5060/article/details/52372448>

**2.如何安全的使用HashMap**

HashMap线程不安全的表现：

​	(1) 两个线程同时尝试扩容HashMap时，可能将形成环形链表，调用get方法时，可能出现死循环。

​	(2) 在多个线程同时put时可能造成一个线程数据的丢失。

安全使用：

​	(1) ConcurrentHashMap，不仅线程安全而且效率高效，因为它包含一个segment数组，将数据分段存储，给每段数据配一把锁，也就是锁分段。这样就可以由原先的只能有一个线程操作表，变成多个线程可以同时操作表，效率大大提高。

​	(2) SynchronizedMap

*参考文章：*<https://blog.csdn.net/u010842515/article/details/68490245>

**3.Spring源码用到的设计模式**

​	(1) 代理模式，AOP，为其他对象提供一种代理以控制对这个对象的访问。

​	(2) 单例模式，scope，采用双重判断加锁的机制。

​	(3) 简单工厂模式，BeanFactory，根据传入的唯一标识来获的bean对象。

​	(4) 工厂方法模式，应用程序将对象的创建及初始化职责交给工厂对象。

​	(3) 模板方法，Spring jdbcTemplate，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

​	(4) 策略模式，spring实例化对象的时候用到Strategy模式。



**1000亿的大数据，找出其中最大的十万个数**

​	Hash分成小文件，每个小文件进行Hash统计，取出前十万大的数字。然后维护一个十万大小的堆，多个文件得出最大的十万个数。

**1000亿的大数据，全排序**

​	Hash分成小文件，每个小文件内部进行快排，得到多个有序小文件，然后多路归并排序。

