复习

## 数据库

**1.数据库范式**

第一范式：数据库表的每一列都是不可分割的原子数据项。

第二范式：在1NF的基础上，非码属性必须完全依赖于候选码。

第三范式：在2NF的基础上，任何非主属性不依赖于其他非主属性（消除传递依赖）。

**2.事务的隔离级别**

Read uncommitted：一个事务可以读取到另一个事务未提交的数据。会发生 脏读。

Read committed：一个事务要等另一个事务提交后才能读取数据。会发生 不可重复读。

Repeatable read：在事务开启后，不再允许修改操作。会发生 幻读

Serializable ：最高级别，事务串行化顺序执行。

**3.事务的ACID**

A：原子性，C：一致性，I：隔离性，D：持久性。

**4.索引**

​	索引可以大大提高MySQL的检索速度。但是会降低表的更新速度，进行增、删、改操作时，不仅要保存数据，还要保存索引文件。

**索引类型：**

​	普通索引、组合索引、唯一索引、主键索引、全文索引。

​	联合索引：(a,b,c) 先查找a，找到匹配的后再查找b，依次查找

​	mysql有最左匹配原则

*参考文章：*<https://blog.csdn.net/u013164931/article/details/82386555>

**应用场景：**

1.表的某个字段值的离散度越高，该字段越适合选作索引的关键句子。主键/唯一性约束字段。

2.占用存储空间少的字段更适合选做索引的关键字。

3.存储空间固定的字段更适合做索引的关键字。

4.where子句中经常使用的字段，分组字段，排序字段，两个表的连接字段。

5.更新频繁的字段不适合。

6.最左前原子。

7.尽量使用前缀索引。

*参考文章：*<https://blog.csdn.net/aa1215018028/article/details/80982208>

​		   <https://www.cnblogs.com/tangchuanyang/p/6013151.html>

**底层结构：**

​	B树或B+树，因为B+树很适合文件系统查找。使用磁盘I/O次数评价索引结构的优劣，根据B-树的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙的利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。

*参考文章：*<https://www.cnblogs.com/boothsun/p/8970952.html>

**创建索引**

```CREATE INDEX indexName ON mytable(username(length)); ```

**修改表结构(添加索引)**

```ALTER table tableName ADD INDEX indexName(columnName);```

**创建表时直接指定**

```CREATE TABLE mytable(  
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```

**删除索引**

```DROP INDEX [indexName] ON mytable;```

**表示唯一**：UNIQUE

**显示索引信息**

通过添加 \G 来格式化输出信息。

```SHOW INDEX FROM table_name; \G```

**5.分库分表、主从复制、读写分离**

**垂直切分**

​	垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库中。

​	垂直分表是基于数据库表中的“列”进行的，某个表字段过多，可以新建一张扩展表，将不常用或字段长度较大的字段拆分出去到扩展表中。通过“大表拆小表”，便于开发与维护，也能避免跨页问题，Mysql底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能够加载更多的数据，命中率高，减少了磁盘I/O，从而提升了数据库性能。

优点：

​	解决业务系统层面的耦合，业务清晰。

​	与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等。

​	高并发场景下，垂直切分一定程度的提升IO、数据库连接数的瓶颈。

缺点：

​	部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度。

​	分布式事务处理复杂。

​	依然存在单表数据量过大的问题。（需要水平切分）

**水平切分**

​	库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一表按不同的条件分散到多个数据库或多个表中，每个表只包含一部分数据，从而使单个表的数据量变小。

​	库内分表只解决了单一表数据过大的问题，但没有将表分布到不同机器的库上，因此对减轻Mysql数据库的压力来说，帮助不是很大。大家还是竞争同一个物理机的CPU、内存、网络、IO，最好是通过分库分表解决。

优点：

​	不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力。

​	应用端改造较小，不需要拆分业务模块。

缺点：

​	跨分片的事务一致性难以保证。

​	跨库的join管理查询性能较差。

​	数据多次扩展难度和维护量极大。

数据分片规则：

​	根据数值范围，按照时间区间或ID区间切分。

​	根据数值取模，采用hash取mod的切分方式

分库分表带来的问题：

​	事务一致性问题，跨节点关联查询join问题，跨节点分页、排序、函数问题，全局主键避重问题，数据迁移、扩容问题。

*参考文章：*<https://www.cnblogs.com/butterfly100/p/9034281.html>

## 操作系统

**进程与线程的区别**

​	进程是资源分配的基本单位，它是程序执行的一个实例。程序运行时系统就会创建一个进程，并未它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正执行。

​	线程是程序执行的最小单位，是CPU调度和分派的基本单位。

​	一个进程可以由多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。

区别和优劣：

​	进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段/堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的d地址空间，因此CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程要小的多。

​	线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。不过处理同步与互斥是编写多线程程序的难点。

​	但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也就死掉了，而一个进程死掉并不会对另一个进程造成影响，因为进程有自己独立的地址空间。

**进程通信(IPC)的方式**

​	IPC的方式通常有管道(无名管道、命名管道FIFO)、消息队列、信号量、共享内存、Socket和Stream等，其中Socket和Stream支持不同主机上的两个进程IPC。

管道：速度慢，容量有限，只有父子进程能通讯。

FIFO：任何进程间都能通讯，但速度慢。

消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。

信号量：不能传递复杂消息，只能用来同步。

共享内存区：能够很容易控制容量，速度快、但要保持同步。

*参考文章：*<https://www.cnblogs.com/zgq0/p/8780893.html>

**进程之间如何保证同步**

互斥量、信号量、事件

**进程调度策略**

先来先服务：每次调度都从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。

短进程优先调度算法：从就绪队列中选出一个估计运行时间最短的进程。

时间片轮转法：系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。当时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾。然后，再把处理机分配给就绪队列中新的队首进程，如此重复。

**磁盘调度**

先来先服务：按访问请求到达的先后次序服务。

最短寻道时间优先：优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先。

扫描(电梯)算法：当有访问请求时，磁头按一个方向移动，在移动过程中遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描，否则改变移动方向，并为经过的访问请求服务，如此反复。

循环扫描算法：选择一个方向，单向循环扫描。

**页面置换策略**

FIFO页置换：选择最旧的页进行置换。通过一个队列来管理内存中的所有页面。

最优置换：置换最长时间不适用的页，预测其未来经过多长时间才被使用。可能10、100或1000次才使用一次。

最近最少使用算法：最优置换和FIFO的关键区别在于，FIFO使用的是页调入时间，最优置换使用的是页将来使用时间。将使用离过去最近作为不远将来的近似，那么可置换最长时间没有使用的页。可以用计数器、栈实现。

**死锁**

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。

产生条件：互斥条件、请求与保持条件、不剥夺条件、环路等待条件。

解决方法：死锁预防、死锁避免、死锁的检测和解除。

## Java

**HashMap、Hashtable、CurrentHashMap**

HashMap：

​	初始大小16，每次扩容为2倍，负载因子0.75，允许键值为null，非线程安全。

HashTable：

​	初始大小为11，每次扩容为2倍+1，负载因子0.75，不允许键值为null，线程安全。

CurrentHashMap：

​	与HashMap相差不大，区别是核心输入如value、链表等都是volatile修饰的，保证了获取时的可见性。



优化：可以在创建HashMap前预估其大小，尽量减少扩容带来的性能损耗。

*参考文章：*<https://www.cnblogs.com/fsychen/p/9361858.html>

**消息队列**

使用场景：当不需要立即获得结果，但是并发量有需要进行控制的时候，就需要使用MQ，Message Queue。

四个场景：

​	应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败，导致整个过程失败。

​	比如：上传图片系统，人脸识别系统耦合。

​	异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间。

​	比如：用户注册，邮件和短信并行发送。

​	流量削峰：应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况。

​	比如：秒杀系统，后入队列的用户无法秒杀到商品，这些请求直接被抛弃，返回活动结束或商品已售完信息

消息队列有RabbitMQ，部分数据库Redis、Mysql也可以实现消息队列功能。

*参考文章：*<https://www.cnblogs.com/javalyy/p/8856731.html>

**Spring AOP**

IoC，控制反转：

​	是一种设计思想，就是将原来在程序中手动创建对象的控制权交由Spring框架来管理。Ioc容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map(key,value)，Map中存放的是各种对象。

​	IoC容器就像一个工厂，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象时如何被创建出来的。这样做大大增加了项目的可维护性且降低了开发难度。

AOP：

​	面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

​	Spring AOP是基于动态代理的，属于运行时增强。

连接点：程序执行的某个特定位置。

切点：一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。相当于查询条件、匹配方法。

增强：增强是织入到目标类连接点上的一段程序代码。

引介：引介是一种特殊的增强，它为类添加一些属性和方法。

织入：将增强添加到目标类具体连接点上的过程。AOP有三种织入方式：①编译期织入②装载期织入③运行时织入

切面：切面是由切点和增强组成的。

**SpingMVC工作原理**

​	1.客户端发送请求，直接请求到前端控制器。

​	2.前端控制器根据请求信息调用处理器映射器，解析请求对应的处理器。

​	3.解析到对应的处理器后，由处理器适配器处理。

​	4.处理器适配器会调用真正的处理器开始处理请求，并处理相应的业务逻辑。

​	5.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View

​	6.视图解析器会根据逻辑View找到实际的View。

​	7.前端控制器把返回的Model传给View进行视图渲染。

​	8.把View返回给请求者。

**GC**

判断垃圾算法：

​	引用计数器，某个对象每加一次引用，计数器+1，当计数器为0时，即可清理。缺陷：对象引用成环。

​	可达性分析法：通过"GC Roots"对象作为起始点，从这些点开始向下搜索，搜索走过的路径成为引用链，当一个对象与任何GC Roots对象相连时，则证明对象需要回收。

GC Roots对象：

​	虚拟机栈中引用的对象。

​	方法区中类静态属性引用的对象。

​	方法区中常量引用的对象。

​	本地方法栈中JNI引用的对象。

垃圾回收算法：

​	标记-清除，标记-整理，复制算法、分代收集算法。

**JVM内存结构**

​	有5大内存区域，线程独占的有虚拟机栈、本地方法栈、程序计数器，共享的有方法区和堆。

​	栈内存有一个特点是数据共享，i=1,j=1，i和j会执行同一内存区域。

​	堆内存没有数据共享。

## 计算机网络

HTTP请求首部、HTTP响应首部、IPV6的合法性

请求报文：

​	请求行：由请求方法字段、URL字段和HTTP协议版本3个字段组成。

​	请求头部、空行、请求数据

响应报文：

​	响应行、响应头、响应体

**HTTP**

​	超文本传输协议，它通常运行再TCP上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。明文传输，默认端口是80。

**HTTPS**

​	超文本安全传输协议，它是在HTTP和TCP之间加了一个安全套接字层SSL协议，SSL依靠证书来验证服务器的身份。具有安全的ssl加密传输协议，默认端口是443。

**HTTP缓存机制和原理**

强制缓存：

​	如果缓存里有缓存数据且未失效，直接返回；否则重新请求服务器，返回数据。

对比缓存：

​	首先从缓存里请求到数据的标识，然后发送给服务器，判断标识是否失效。

​	若未效，通知客户端未失效，然后从缓存里请求数据。

​	若失效，返回最新数据和缓存规则，将数据和缓存规则存入缓存系统。

Cache-Control：可以用来设置缓存。

*参考文章：*<https://www.cnblogs.com/chenqf/p/6386163.html>

## 数据结构

循环队列：

​	队满：（Q.rear+1）%MAXQSIZE=Q.front

​	对空：q.front=q.rear

完全二叉树：

​	节点总数n = n0 + n1 + n2 （入度为0即叶子，入度为1，入度为2节点）=2^h-1。h为深度。

​	整理有 n0 = n/2;  n为奇数时向上取整，n为偶数时向下取整。

## 项目经验

