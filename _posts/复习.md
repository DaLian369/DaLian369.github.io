复习

## 数据库

**1.数据库范式**

第一范式：数据库表的每一列都是不可分割的原子数据项。

第二范式：在1NF的基础上，非码属性必须完全依赖于候选码。

第三范式：在2NF的基础上，任何非主属性不依赖于其他非主属性（消除传递依赖）。

**2.事务的隔离级别**

Read uncommitted：一个事务可以读取到另一个事务未提交的数据。会发生 脏读。

Read committed：一个事务要等另一个事务提交后才能读取数据。会发生 不可重复读。

Repeatable read：在事务开启后，不再允许修改操作。会发生 幻读

Serializable ：最高级别，事务串行化顺序执行。

**3.事务的ACID**

A：原子性，C：一致性，I：隔离性，D：持久性。

**4.索引**

​	加速查询的数据结构。

**索引类型：**

​	普通索引、组合索引、唯一索引、主键索引、全文索引。

​	联合索引：(a,b,c) 先查找a，找到匹配的后再查找b，依次查找。

​	mysql有最左匹配原则，如果存在范围索引，那么范围列后面的列无法用到索引。

*参考文章：*<https://blog.csdn.net/u013164931/article/details/82386555>

*参考文章：*<https://blog.csdn.net/aa1215018028/article/details/80982208>

​		   <https://www.cnblogs.com/tangchuanyang/p/6013151.html>

**聚簇索引和非聚簇索引**

聚簇索引：将数据存储和索引放到了一块，找到索引也就找到了数据，一个表仅有一个聚簇索引。

非聚簇索引：将数据存储与索引结构分开，索引结构的叶子节点指向了数据的对应行。

​	myisam通过key_buffer把索引先缓存到内存中，当需要通过索引访问数据时，在内存中直接搜索索引，然后通过索引找到磁盘响应数据，这也是为什么索引不在key_buffer命中时，速度慢的原因。

*参考文章：*<https://www.jianshu.com/p/fa8192853184>

**索引常见数据结构**

顺序查找，时间复杂度为O(n)

二叉树查找，时间复杂度为O(logn)

hash索引，不能满足范围查找

B-Tree：

​	结构：B-Tree每个节点都是一个二维数组：[key, data]，所有节点都可以存储数据。key为索引key，data为索引之外的数据。

​	检索原理：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或未找到节点返回null指针。

​	缺点：1.插入删除数据会破坏B-Tree的性质，因此在插入删除时，需要对树j进行分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。 2.区间查找可能需要返回上层节点重复遍历，IO操作繁琐。

B+Tree：

​	非叶子节点不存储data，之存储索引key，只有叶子节点存储data。

​	Mysql中的B+Tree：在经典的B+Tree的基础上做了优化，增加了顺序访问指针。在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree，提高了区间访问性能。

*参考文章：*<https://www.jianshu.com/p/486a514b0ded>

**底层结构：**

​	B树或B+树，因为B+树很适合文件系统查找。使用磁盘I/O次数评价索引结构的优劣，根据B-树的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙的利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。

*参考文章：*<https://www.cnblogs.com/boothsun/p/8970952.html>

**创建索引**

```CREATE INDEX indexName ON mytable(username(length)); ```

**修改表结构(添加索引)**

```ALTER table tableName ADD INDEX indexName(columnName);```

**创建表时直接指定**

```CREATE TABLE mytable(  
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```

**删除索引**

```DROP INDEX [indexName] ON mytable;```

**表示唯一**：UNIQUE

**显示索引信息**

通过添加 \G 来格式化输出信息。

```SHOW INDEX FROM table_name; \G```

**5.SQL优化**

核心：怎么合理创建索引、怎么使用索引、索引失效、合理创建表字段

具体：

​	(1) 在子查询中慎重使用IN或者NOT IN语句，使用where (NOT) exists的效果要好的多或用join代替，小表关联大表。（索引失效）

​	(2) 对查询进行优化，要尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。（怎么创建索引）

​	(3) 最好不要给数据库留NULL，尽可能的使用NOT NULL填充数据库。（合理创建表字段）

​	(4) 尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。（索引失效）

​	(5) 尽量避免在where子句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。（索引失效）

​	(6) 注意最左前缀匹配原子。（索引失效）

**6.分库分表**

**垂直切分**

​	垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库中。

​	垂直分表是基于数据库表中的“列”进行的，某个表字段过多，可以新建一张扩展表，将不常用或字段长度较大的字段拆分出去到扩展表中。通过“大表拆小表”，便于开发与维护，也能避免跨页问题，Mysql底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能够加载更多的数据，命中率高，减少了磁盘I/O，从而提升了数据库性能。

**水平切分**

​	库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一表按不同的条件分散到多个数据库或多个表中，每个表只包含一部分数据，从而使单个表的数据量变小。

​	库内分表只解决了单一表数据过大的问题，但没有将表分布到不同机器的库上，因此对减轻Mysql数据库的压力来说，帮助不是很大。大家还是竞争同一个物理机的CPU、内存、网络、IO，最好是通过分库分表解决。

分库分表带来的问题：

​	事务一致性问题，跨节点关联查询join问题，跨节点分页、排序、函数问题，全局主键避重问题，数据迁移、扩容问题。

**分库分表策略**

​	Hash取模、范围分片、地理分片、时间分片。

**分布式事务问题**

​	跨库join的问题、横向扩容问题、结果集合并、排序的问题。

**使用分库分表中间件**

​	

*参考文章：*<https://www.cnblogs.com/butterfly100/p/9034281.html>

**7.MySQL主从复制、读写分离**

​	DQL数据查询语言、DML数据操纵语言、DDL数据定义语言、数据控制语言DCL

​	mysql从3.23版本开始提供复制功能，复制是将主库的DDL和DML操作通过二进制日志传递到复制服务器上，然后从库对这些日志重新执行，从而使得主库和从库保持数据一致。

复制原理：

​	(1) 首先MySQL主库在事务提交时会把数据库变更作为事件Events记录在二进制binlog中；mysql主库上的sys_binlog控制binlog日志刷新到磁盘。

​	(2) 主库推送二进制文件binlog中的事件到从库的中继日志relay log，之后从库根据中继日志重做数据库变更操作。通过逻辑复制，以此来达到数据一致。

​	MySQL通过3个线程来完成主从库之间的数据复制：其中BinLog Dump线程跑在主库上，I/O线程和SQL线程跑在从库上。当从库启动复制(start slave)时，首先创建I/O线程连接主库，主库随后创建BinLog Dump线程读取数据库事件并发给I/O线程，I/O线程获取到数据库事件更新到从库的中继日志Realy log中去，之后从库上的SQL线程读取中继relay log中更新的数据库事件并应用。

**8.数据库 like**

sql语句中利用like实现模糊查询，%匹配0或多个字符，_匹配单一字符。

**10.表、视图、索引、存储过程、函数**

表是由字段、关系等描述信息组成，是数据库的基础。

视图是虚拟表，本质是针对表的SQL子查询。

索引用来快速查询特定记录，为了提高查询效率而构建的。

存储过程为了完成特定功能的SQL语句集。

**11.MySQL两种存储引擎**

MyISAM、Innodb：

​	(1) 事务支持。MyISAM不支持事务，而Innodb支持。InnoDB的autoconmmit默认是打开的，即每条sql语句都会默认被封装为一个事务，自动提交。但是这样会影响速度，最好显示把多条SQL语句放在begin和commit之间提交。MyISAM是非事务安全型的，而InnoDB是事务安全型的

​	(2) 锁的粒度。MyISAM只支持表级锁，InnoDB支持事务和行级锁。

​	(3) 全文索引。MyISAM支持全文索引，InnoDB不支持全文索引。

​	(4) 表的具体行数。MyISAM保存有表的行数，InnoDB，没有保存，会遍历整张表统计。

​	(5) 键：MyISAM不支持主外键，InnoDB支持。

应用场景：

​	(1) MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM。

​	(2) InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB。

*参考文章：*<https://www.jianshu.com/p/2d819e57945f>

​		   <https://blog.csdn.net/printwsl/article/details/80058841>

## 操作系统

**进程与线程的区别**

​	进程是资源分配的基本单位，它是程序执行的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正执行。

​	线程是程序执行的最小单位，是CPU调度和分派的基本单位。

​	一个进程可以由多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。

区别和优劣：

​	进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程要小的多。

​	线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。不过处理同步与互斥是编写多线程程序的难点。

​	但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也就死掉了，而一个进程死掉并不会对另一个进程造成影响，因为进程有自己独立的地址空间。

​	多进程指操作系统能同时运行多个任务（程序）。

​	多线程是指同一程序中有多个线程在执行。

**为什么要线程同步**

线程有可能和其他线程共享一些资源，但是当多个线程同时读写一份共享资源的时候，可能会发生冲突。所以需要线程同步，确保某一时刻只有一个线程能够操作共享资源。

**进程通信(IPC)的方式**

​	IPC的方式通常有管道(无名管道、命名管道FIFO)、消息队列、信号量、共享内存、Socket和Stream等，其中Socket和Stream支持不同主机上的两个进程IPC。

管道：速度慢，容量有限，只有父子进程能通讯。

FIFO：任何进程间都能通讯，但速度慢。

消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。

信号量：不能传递复杂消息，只能用来同步。

共享内存区：能够很容易控制容量，速度快、但要保持同步。

*参考文章：*<https://www.cnblogs.com/zgq0/p/8780893.html>

**进程之间如何保证同步**

互斥量、信号量、事件

**进程调度策略**

先来先服务：每次调度都从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。

短进程优先调度算法：从就绪队列中选出一个估计运行时间最短的进程。

时间片轮转法：系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。当时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾。然后，再把处理机分配给就绪队列中新的队首进程，如此重复。

**磁盘调度**

先来先服务：按访问请求到达的先后次序服务。

最短寻道时间优先：优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先。

扫描(电梯)算法：当有访问请求时，磁头按一个方向移动，在移动过程中遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描，否则改变移动方向，并为经过的访问请求服务，如此反复。

循环扫描算法：选择一个方向，单向循环扫描。

**页面置换策略**

FIFO页置换：选择最旧的页进行置换。通过一个队列来管理内存中的所有页面。

最优置换：置换最长时间不适用的页，预测其未来经过多长时间才被使用。可能10、100或1000次才使用一次。

最近最少使用算法：最优置换和FIFO的关键区别在于，FIFO使用的是页调入时间，最优置换使用的是页将来使用时间。将使用离过去最近作为不远将来的近似，那么可置换最长时间没有使用的页。可以用计数器、栈实现。

**死锁**

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。

产生条件：互斥条件、请求与保持条件、不剥夺条件、环路等待条件。

解决方法：死锁预防、死锁避免、死锁的检测和解除。

## Java

**HashMap、Hashtable、ConcurrentHashMap**

HashMap：

​	初始大小16，每次扩容为2倍，负载因子0.75，允许键值为null，非线程安全。

​	1.8版本之前是位桶+链表，1.8之后时位桶+链表/红黑树，这样他的put操作的时候就需要判断链表还是树，插入后需不需要转化成树。另外1.8之前底层使用的是一个Entry数组，1.8改为了Node。

​	另外一个就是扩容机制，1.7在resize的时候首先建两倍大小的数组，遍历旧数组的每个元素，直接重新计算新的索引位置，然后头插法往拉链里填充。1.8之后会把链表上的键值按hash值分为lo和hi两串，lo串的新索引与原位置相同，hi串的新索引位置为 原位置+oldCap。

HashTable：

​	初始大小为11，每次扩容为2倍+1，负载因子0.75，不允许键值为null，线程安全。

ConcurrentHashMap：

​	与HashMap相差不大，区别是核心输入如value、链表等都是volatile修饰的，保证了获取时的可见性。其主要有三个实体类：ConcurrentHashMap(整个Hash表)，Segment(桶)，HashEntry(节点)，使用了分段锁。

优化：可以在创建HashMap前预估其大小，尽量减少扩容带来的性能损耗。

HashTable和ConcurrentHashMap参考文章二。

HashMap为何不是线程安全？

​	HashMap在插入元素过多的时候需要进行Resize，Hashmap的Resize包括扩容和ReHash两个步骤，ReHash在并发情况下可能会形成链表环，在调用get的时候就会发生死循环。参考文章3。

*参考文章：*<https://www.cnblogs.com/fsychen/p/9361858.html>

​		   https://blog.csdn.net/liuzhengkang/article/details/2916620

 		  <https://blog.csdn.net/wufaliang003/article/details/80219296>

**hashcode和equals作用**

​	hashCode会返回对象的一个哈希值。

​	equals会比较对象的hashCode。

​	如果不重写这两个方法，子类都将直接继承Object的两个方法，即比较对象的地址。而我们希望的一般是比较内容，所以需要重写。

**==和equals**

​	==专门用来比较两个基本类型的数据或两个引用变量是否相等。

​	equals用来比较两个独立对象的内容是否相同。

**接口和抽象类**

相同点：都可以被继承、不能被实例化、可以包含方法声明、派生类必须实现未实现的方法。

不同点：

​	①抽象类可以有构造方法，接口中不能有构造方法。

​	②抽象类可以有普通成员变量，接口中没有普通成员变量。

​	③抽象类可以包含静态方法，接口中不能包含静态方法。

​	④一个类可以实现多个接口，但只能继承一个抽象类。

​	⑤接口可以被多重实现，抽象类只能被单一继承。

​	⑥如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法。

**线程顺序执行**

实现：

​	(1) 使用线程的join方法

​	(2) 使用主线程的join方法

​	join()：是Thread的方法，作用是调用线程需等待该join()线程执行完成后，才能继续向下运行。

应用场景：当一个线程必须等待另一个线程执行完毕时才能使用join方法。

```java

public class ThreadJoin {
	public static void main(String[] args) {
		Thread thread1 = new Thread(new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				System.out.println("产品经理规划新需求");
			}
		});
		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				try {
					thread1.join();
					System.out.println("开发人员开发新需求功能");
				}catch(Exception e) {
					System.out.println(e);
				}
			}
		});
		Thread thread3 = new Thread(new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				try {
					thread2.join();
					System.out.println("测试人员测试新功能");
				}catch(Exception e) {
					System.out.println(e);
				}
			}
		});
		thread3.start();
		thread2.start();
		thread1.start();
	}
}
```

在主线程中使用join来实现对线程的阻塞。

```java

public class ThreadJoin {
	public static void main(String[] args) throws InterruptedException {
		Thread thread1 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("产品经理规划新需求");
			}
		});
		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("开发人员开发新需求功能");
			}
		});
		Thread thread3 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println("测试人员测试新功能");
			}
		});
		System.out.println(1);
		thread1.start();
		System.out.println(2);
		thread1.join();
		System.out.println(3);
		thread2.start();
		System.out.println(4);
		thread2.join();
		System.out.println(5);
		thread3.start();
	}
}
```

**线程状态**

​	NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED

**构建多线程的方式**

​	(1) 继承Thread类

​	(2) 实现Runnable接口

​	(3) 实现Callable接口

​	(4) 线程池

*参考文章：*<https://www.cnblogs.com/zhou-test/p/9811771.html>

**线程池**

​	如果通过集成Thread类和实现Runnable接口创建线程，如果线程数量多的话，频繁的创建和销毁会大大浪费时间和效率，更浪费内存！线程池可以用来管理线程，使线程重复使用。

ThreadPoolExecutor 参数：

​	corePoolSize：核心线程池的大小。

​	maximunPoolSize：线程池能创建最大的线程数量。

​	keepAliveTime：非核心线程能够空闲的最长时间，超过时间，线程终止。

​	unit：时间单位，和keepAliveTime配合使用。

​	workQueue：缓存队列，用来存放等待被执行的任务。

​	threadFactory：线程工厂，用来创建线程，有三种。

​	handler：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，有四种。

线程池状态：

​	RUNNING、SHUTDOWN、STOP、TERMINATED

*参考文章：*<https://www.cnblogs.com/zzuli/p/9386463.html>

**JDK和JRE的区别**

​	JRE是java运行时环境，包含了java虚拟机、java基础类库。是使用java语言编写的程序运行所需要的软件环境，还有所有的Java类库的class文件，都在lib目录下，并且都打包成了jar。

​	JDK是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java调试和分析的工具软件。

**Java中IO框架的设计模式**

​	装饰模式和适配器模式。

*参考文章：*<https://www.cnblogs.com/wxgblogs/p/5649933.html>

**消息队列**

使用场景：当不需要立即获得结果，但是并发量有需要进行控制的时候，就需要使用MQ，Message Queue。

四个场景：

​	异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。

​	应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。

​	流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。

​	日志处理 - 解决大量日志传输。

​	消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。

消息队列有RabbitMQ，部分数据库Redis、Mysql也可以实现消息队列功能。

两种模式：

​	点对点模式：消息队列、生产者、消费者

​	发布/订阅模式：角色主题、发布者、订阅者

*参考文章：*<https://www.cnblogs.com/javalyy/p/8856731.html>

​		   <https://www.cnblogs.com/javafirst0/p/11126698.html>

**Spring AOP**

**IoC，控制反转：**

​	是一种设计思想，就是将原来在程序中手动创建对象的控制权交由Spring框架来管理。Ioc容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map(key,value)，Map中存放的是各种对象。

​	IoC容器就像一个工厂，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象时如何被创建出来的。这样做大大增加了项目的可维护性且降低了开发难度。**IoC最大的意义在于解耦合。**

​	实现：① 使用XML配置的方式实现IOC   ②使用Spring注解配置IOC

**AOP：**

​	面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

连接点：程序执行的某个特定位置。

切点：一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。相当于查询条件、匹配方法。

增强：增强是织入到目标类连接点上的一段程序代码。

​	前置增强@Before，后置增强@After，返回增强@AfterReturning，异常增强@AfterThrowing

​	环绕增强@Around

引介：引介是一种特殊的增强，它为类添加一些属性和方法。

织入：将增强添加到目标类具体连接点上的过程。AOP有三种织入方式：①编译期织入②装载期织入③运行时织入

切面：切面是由切点和增强组成的。

*参考文章：*<https://blog.csdn.net/deniro_li/article/details/80708210>

**Spring注解**

(1) @Configuration注解

​	该类等价于XML中配置beans，相当于IoC容器，它的某个方法头上如果加了@Bean，就会作为Spring容器的Bean，与xml中配置bean意思一样。

(2) @Value注解

​	为了简化从properties里取配置，可以使用@Value。

(3) @Controller、@Service、@Repository、@Component

(4) @PostConstruct、@PreDestory

​	实现初始化和销毁bean之前进行的操作，只能有一个方法可以用此注解，方法不能有参数，返回值是void，非静态的。

(5) @Primary

​	自动装配时，当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常。

(6) @Lazy(true)

​	用于指定该Bean是否取消预初始化，用于注解类，延迟初始化。

(7) @Autowired

​	Autowired默认先按byType，如果发现找到多个bean，则又按照byName方式比对，如果还有多个，则报出异常。可以手动指定按byName方式注入，使用@Qualifier。

(8) @Resource

​	默认按byName自动注入，如果再找不到按byType找bean，还是找不到则抛出异常，无论按byName还是byType，如果找到多个，则抛出异常。

(9) @Async

​	标注类，类的方法全为异步方法，标注方法，该方法是异步方法。

(10) @Singleton

​	只要在类上加上这个注解，就可以实现一个单例类，不需要自己手动编写单例实现类。

(11) @CrossOrigin

​	作用是解决跨域访问的问题。

(12) @Scope

​	配置bean的作作用域。singleton 单例，prototype由程序员控制对象的生命周期，request，每一次http请求都会产生bean。

(13) @RequestMapping

​	处理映射请求的注解。value请求路径，method请求方法。

*参考文章：*<https://blog.csdn.net/weixin_39805338/article/details/80770472>

**核心原理：使用JDK动态代理和cglib动态代理技术来实现的。**

​	(1) JDK动态代理：通过实现InvocationHandlet接口，并重写里面的invoke方法，通过proxy类指定classLoader和一组interfaces来创建动态代理。

​	(2) cglib的动态代理：CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。

*参考文章：*<https://blog.csdn.net/reallycold/article/details/82144454>

**静态代理和动态代理**

​	代理模式的目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。

按代理的创建时期，代理类可分为2类：

​	静态代理：由程序员创建代理类或特定工具自动生成源代码在对其编译。在程序运行前代理类的.class文件就已经存在了。

​	如果代理的方法很多，势必要为每一种方法都进行代理。或者，如果增加一个方法，除了实现类需要实现这个方法外，所有的代理类也要实现此方法，增加了代码的维护成本。需使用动态代理解决。

​	动态代理：动态代理类的源码在程序运行时运用反射机制动态生成，代理类和委托类的关系是运行时确定的

*参考文章：*https://blog.csdn.net/yinni11/article/details/80217241>

**SpingMVC工作原理**

​	1.客户端发送请求，直接请求到前端控制器。

​	2.前端控制器根据请求信息调用处理器映射器，解析请求对应的处理器。

​	3.解析到对应的处理器后，由处理器适配器处理。

​	4.处理器适配器会调用真正的处理器开始处理请求，并处理相应的业务逻辑。

​	5.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View

​	6.视图解析器会根据逻辑View找到实际的View。

​	7.前端控制器把返回的Model传给View进行视图渲染。

​	8.把View返回给请求者。

**MyBatis和Hibernate比较**

​	Hibernate对数据库结构提供了较为完整的封装。

​	MyBatis主要着力点在于pojo与SQL之间的映射关系。

1.两者最大的区别：

​	针对简单逻辑，Hibernate和MyBatis都有相应的代码生成工具，可以生成简单基本的DAO层方法。

​	针对高级查询，MyBatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。

2.开发难度

3.sql书写

4.数据库扩展性

5.缓存机制

总结：

​	MyBatis：小巧、方便、高校、简单、直接、半自动

​	Hibernate：强大、方便、高校、复杂、绕弯子、全自动

*参考文章：*<https://blog.csdn.net/qq_41378597/article/details/88070335>

**MyBatis一级缓存和二级缓存**

​	mybatis默认开启一级缓存，只是相当于同一个SqlSession而言的，一级缓存的生命周期，怎么判断两次查询是相同查询。

​	mybatis二级缓存是Application级别的，可以提高对数据库查询的效率，以提高应用的性能。

​	开启二级缓存，需要pojo必须是可序列化的，也就是必须实现Serializable接口，并且在映射文件XML文件里配置就可以开启缓存了。

*参考文章：*<https://www.cnblogs.com/happyflyingpig/p/7739749.html>

**GC**

判断垃圾算法：

​	引用计数器，某个对象每加一次引用，计数器+1，当计数器为0时，即可清理。缺陷：对象引用成环。

​	可达性分析法：通过"GC Roots"对象作为起始点，从这些点开始向下搜索，搜索走过的路径成为引用链，当一个对象与任何GC Roots对象相连时，则证明对象需要回收。

GC Roots对象：

​	虚拟机栈中引用的对象。

​	方法区中类静态属性引用的对象。

​	方法区中常量引用的对象。

​	本地方法栈中JNI引用的对象。

垃圾回收算法：

​	标记-清除，标记-整理，复制算法、分代收集算法。

**JVM内存结构**

​	有5大内存区域，线程独占的有虚拟机栈、本地方法栈、程序计数器，共享的有方法区和堆。

​	栈内存有一个特点是数据共享，i=1,j=1，i和j会执行同一内存区域。

​	堆内存没有数据共享。

**Java引用类型**

强引用：

​	平常大部分使用的就是强引用。当内存空间不足时，Java虚拟机宁愿抛出OOM错误，使程序异常终止，也不会随意回收具有强引用的对象来解决内存不足问题。相当于生活中的必需品。

软引用：

​	如果内存足够，垃圾回收器就不会回收它，如果内存不足，就会回收这些对象。软引用可用来实现内存敏感的高速缓存。相当于可有可无的生活用品。

弱引用：

​	与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现只具有弱引用的对象，不管内存足够与否，都会回收它的内存。

虚引用：

​	在任何时候都可能被垃圾回收，虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用、弱引用的区别是，它必须和引用队列联合使用。

*参考文章：*<https://blog.csdn.net/junjunba2689/article/details/80601729>

## 计算机网络

HTTP请求首部、HTTP响应首部、IPV6的合法性

请求报文：请求行、请求头部、空行、请求数据

响应报文：状态行、消息报头、响应正文。

**HTTP**

​	超文本传输协议，它通常运行再TCP上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。明文传输，默认端口是80。

**HTTPS**

​	超文本安全传输协议，它是在HTTP和TCP之间加了一个安全套接字层SSL协议，SSL依靠证书来验证服务器的身份。具有安全的ssl加密传输协议，默认端口是443。

**HTTP缓存机制和原理**

强制缓存：

​	如果缓存里有缓存数据且未失效，直接返回；否则重新请求服务器，返回数据。

对比缓存：

​	首先从缓存里请求到数据的标识，然后发送给服务器，判断标识是否失效。

​	若未效，通知客户端未失效，然后从缓存里请求数据。

​	若失效，返回最新数据和缓存规则，将数据和缓存规则存入缓存系统。

Cache-Control：可以用来设置缓存。

*参考文章：*<https://www.cnblogs.com/chenqf/p/6386163.html>

**7层协议**

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

**TCP和UDP的区别**

​	TCP，传输控制协议，提供的是面向连接，可靠的字节流服务。即客户和服务器交换数据之前，必须在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端到另一端。

​	相关协议：HTTP、HTTPS、SMTP

​	UDP，用户数据报协议，是一个简单的面向数据报的协议。它不提供可靠性，只是把应用程序传给IP层的数据包发送出去，但是不能保证它到达目的地。发送时，不需要建立连接，且没有超时重发等机制，所以传输速度快。

​	相关协议：DNS、TFTP

*参考文章：*

**三次握手**

三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。

第一次：客户端发送SYN包到服务器，并进入SYN_SENT状态，等待服务器确认。

第二次：服务器收到SYN包，必须确认客户的SYN，同时自己也发送一个SYN包，即SYN+ACK包，进入SYN_RECV状态。

第三次：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

**四次挥手**

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。

(1) 客户端发送一个FIN，用来关闭客户到服务器的数据传输。客户端进入FIN_WAIT_1。

(2) 服务器收到这个FIN，会发回一个ACK。服务端进入CLOSE_WAIT。

(3) 客户端收到这个ACK，进入FIN_WAIT_2状态

(4) 服务器关闭客户端的连接，发送一个FIN给客户端。服务器进入LAST_ACK状态。

(5) 客户端发回ACK确认包，进入TIME_WAIT状态，此时需要等待2MSL(长报文寿命)的时间后，当客户端撤销响应的TCB后，进入CLOSED状态。

(6) 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。服务器结束TCP连接比客户端早一些。

FIN不携带数据。

**【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？**

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

**【问题3】为什么不能用两次握手进行连接？**

答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

​	现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

**【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？**

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

**对称与非对称加密算法**

对称加密算法

​	指加密和解密使用相同密钥的算法。对称加密算法用来对敏感数据等信息进行加密，常用的算法有DES、3DES、AES、DESX、Blowfish、RC4、RC5、RC6

非对称加密算法

​	指加密和解密使用不同秘钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方则用自己的私钥解密。常见的非对称加密算法有：RSA、DSA、ECC、EI Gamal、Diffie-Hellam等。

**网页服务单进程多线程好还是多进程单线程好？**

​	资源、稳定性、响应速度

​	单进程多线程，响应速度快，但不稳定，一个线程死了，整个进程都会挂掉。

​	多进程单线程，稳定性好，占用资源多，响应速度不如单进程快。

**直播业务用什么？改进UDP**

​	进行压缩传输，在客户端解码。

**Ping命令的工作原理**

首先Ping命令会构建一个固定格式的ICMP请求数据包，然后由ICMP协议将这个数据包连同目标地址一起交给IP层协议，IP层协议将构建一个IP数据包，通过ARP协议查找到目标地址对应的MAC地址，一并交给数据链路层。数据链路层构建一个数据帧，依据以太网的介质访问规则，将它们传送出去。

主机B收到这个数据帧后，比较它的目的地址和本机的MAC地址，若匹配，则接受；否则丢弃。接受后将IP数据包从数据帧中提取出来，交给IP层协议。IP层检查后，将有用的信息提取后交给ICMP协议。ICMP处理后，构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B一样。

**get请求和post请求的区别**

(1) get重点在从服务器上获取资源，post重点在向服务器发送数据。

(2) get传输数据时通过url，以字段=value的形式，至于url之后，以"?"连接，多个数据之间用"&"连接

​     post传输数据通过Http的post机制，将字段封存在请求体中发送给服务器。

(3) get的传输数据量较小，受浏览器的限制，但效率较高。

​     post可以传输大量数据。

(4) get只能支持ASCII字符，向服务器传的中文字符可能会乱码。

​      post支持标准字符集，可以正确传递中文字符。

(5) 二者都是不安全的，因为HTTP都是明文传输，要想安全传输，只有加密，也就是HTTPS。

**cookie和session的区别**

​	HTTP请求是无状态的，就是说第一次和服务器连接并且登陆成功后，第二次请求，服务器依然不能知道当前请求是哪一个用户，cookie的出现就是为了解决这个问题。第一次登录后服务器返回一些数据(cookie)给浏览器保存到本地，当该用户第二次请求时，就会自动的把上一次请求存储的cookie数据自动的携带给服务器。服务器通过浏览器携带的数据就能判断是哪一个用户了。cookie大小一般不超过4KB。

​	session和cookie的作用优点类似，都是为了存储用户相关的信息。不同的是cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加安全，不容易窃取，但会占用服务器的资源。

​	两种常用的存储方式：

​	①存储在服务器端：通过cookie存储一个session_id，然后具体的数据则保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

​	②将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。

*参考文章：*<https://blog.csdn.net/a754895/article/details/82632747>

**网站中输入一个url的过程**

① 域名解析

② TCP连接、三次握手

​	HTTP协议是使用TCP协议作为其传输协议的，在拿到服务器的IP地址后，浏览器客户端会与服务器建立TCP连接，该过程包括三次握手。

③ 浏览器发送HTTP请求

​	浏览器构件HTTP请求报文，并通过TCP协议传送到服务器的指定端口。HTTP请求报文包括：请求行、请求头、空行、请求体。

④ 服务器处理HTTP请求

​	服务器处理HTTP请求，并返回响应报文，包括：状态码、响应头、响应正文。

⑤ 浏览器页面渲染

​	浏览器接收到服务器发送过来的响应问，并开始解析html文档，渲染页面。

⑥ 断开TCP连接

​	客户端与服务器四次挥手，断开tcp连接。 

## 数据结构

循环队列：

​	队满：（Q.rear+1）%MAXQSIZE=Q.front

​	对空：q.front=q.rear

完全二叉树：

​	节点总数n = n0 + n1 + n2 （入度为0即叶子，入度为1，入度为2节点）=2^h-1。h为深度。

​	整理有 n0 = n/2;  n为奇数时向上取整，n为偶数时向下取整。

**B-树和B+树**

B-树：多路平衡搜索树

​	 根节点至少两个子节点；

​	 每个中间节点都包含k-1个元素和k个孩子，其中m/2 <= k <=m；

​	 每一个叶子节点都包含k-1个元素，其中m/2 <=k <= m；

​	 所有叶子节点位于同一层；

​	 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分。

​	 关键字集合分布在整棵树中；

​	 任何一个关键字出现且只出现在一个节点中；

​	 搜索有可能在非叶子节点结束；

B+树：B-树的一种变体，拥有更高的查询性能。

​	1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

​	2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

​	3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

*参考文章：*<https://blog.csdn.net/qq_35571554/article/details/82759668>

## 算法

![](F:\desk\md\图片\排序算法.png)

*参考文章：*<https://blog.csdn.net/yuxin6866/article/details/52771739>

## Linux

查看实时文件更新：tail

查看文件夹下的文件：ls

移动文件、更改文件吗：mv

查看进程：ps

*参考文章：*<https://blog.csdn.net/q357010621/article/details/80248611>

## 项目经验

钱的数据类型：BigDecimal

**etcd前端：**

​	使用了国际化插件vue-i18n，利用npm建立依赖。然后首先创建了一个i18n实例对象，方便全局调用。通过一个事件来进行语言的选择，可以选择简体中文、繁体中文和英文。然后就是自定义语言包，在html里进行渲染。

​	跨域问题的出现是因为浏览器的同源策略，官方描述就是同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。解决办法是首先设置后端可以接受option请求，然后在返回响应的时候设置带有“Access-Control"访问控制的响应头。接受option请求，是因为复杂请求在正式通信之前，会增加一次HTTP查询请求，来进行预检。如果不设置option请求，便将不会出现400错误。

**PE癫痫预测系统**

​	WebSocket

**药品存销信息管理系统**

​	数据库设计，mybatis使用了二级缓存，提高了数据库查询的效率，并且开了一台虚拟机，本地和虚拟机上分别创建了一个数据库，本地用来写，虚拟机上用来读。主要是在访问数据库前加了一层切面进行判断，如果是要读就让它访问虚拟机数据库，如果是写，就访问本地数据库。

​	乱码问题，mysql的编码方式和前端页面的乱码。



## 面经

**1.如何构建互联网高性能WEB系统**

(1) 缓存

​	DNS缓存、数据库缓存、分布式缓存

(2) 拆分

​	业务拆分、数据库拆分

(3) 异步

​	网络异步、磁盘异步、使用消息

*参考文章：*<https://blog.csdn.net/cxh5060/article/details/52372448>

**2.如何安全的使用HashMap**

HashMap线程不安全的表现：

​	(1) 两个线程同时尝试扩容HashMap时，可能将形成环形链表，调用get方法时，可能出现死循环。

​	(2) 在多个线程同时put时可能造成一个线程数据的丢失。

安全使用：

​	(1) ConcurrentHashMap，不仅线程安全而且效率高效，因为它包含一个segment数组，将数据分段存储，给每段数据配一把锁，也就是锁分段。这样就可以由原先的只能有一个线程操作表，变成多个线程可以同时操作表，效率大大提高。

​	(2) SynchronizedMap

*参考文章：*<https://blog.csdn.net/u010842515/article/details/68490245>

**3.Spring源码用到的设计模式**

​	(1) 代理模式，AOP，为其他对象提供一种代理以控制对这个对象的访问。

​	(2) 单例模式，scope，采用双重判断加锁的机制。

​	(3) 简单工厂模式，BeanFactory，根据传入的唯一标识来获的bean对象。

​	(4) 工厂方法模式，应用程序将对象的创建及初始化职责交给工厂对象。

​	(3) 模板方法，Spring jdbcTemplate，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

​	(4) 策略模式，spring实例化对象的时候用到Strategy模式。



**4.1000亿的大数据，找出其中最大的十万个数**

​	Hash分成小文件，每个小文件进行Hash统计，取出前十万大的数字。然后维护一个十万大小的堆，多个文件得出最大的十万个数。

**5.1000亿的大数据，全排序**

​	Hash分成小文件，每个小文件内部进行快排，得到多个有序小文件，然后多路归并排序。

**6.内存泄露和内存溢出**

内存溢出(OOM)：系统不能再分配你需要的空间，有上溢和下溢。

内存泄露(Memory Leak)：一个对象分配内存之后，在使用结束时未及时释放，导致一直占用内存，没有及时清理，使实际可用内存减少。

大量的内存泄露会导致内存溢出。

内存溢出的原因：

​	①内存中加载的数据量过于庞大，如一次从数据库取出过多数据。

​	②集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。

​	③代码中存在死循环或循环中产生过多重复的对象。

​	④启动参数内存值设定的过小。

**7.什么是SQL注入**

​	通过把SQL命令插入到WEB表单提交的查询字符串中，被插入到执行的实体字段中。

防护：

​	前端通过正则表达式设置校验。

​	不要使用动态拼接sql，可以使用参数化的sql，用填充sql语句中的 ？ 号。

mybatis防护：

​	#{}：相当于JDBC中的PreparedStatement

​	${}：是输出变量的值

**8.直接调用线程的run()方法会发生什么情况**

​	相当于调用对象方法，执行方法体。

**9.throw和throws有什么区别**



**10.什么时候使用throws，什么时候使用try...catch...**



**HR面经**

1.为什么要用你，你与其他人竞争者的优势是什么？

​	技术方面我觉得都是大同小异的，我觉的我的优势一个在于我的性格，比较踏实认真负责，也容易相处，另一个就是快速学习能力，我觉的我的快速学习能力还是不错的。比如说，实习时候的etcd集群、Vue框架等等。

2.你有什么想问我的？

​	对于技术面来说，可以问下部门的业务情况，所用到的技术栈，

​	对于hr面来说，可以问对刚入职同学的培训情况、住宿、餐补等问题。

3.如果公司需要你加班，你有什么问题吗？

​	没有问题，因为我愿意花更多的时间，来积累更多的经验，学到更多的东西。

4.为什么不选择考研？



5.经常浏览的技术网站有哪些，看过那些书？

​	看过的书主要有 深入理解JVM和一些数据结构算法书。

​	技术网站主要有：CSDN来看别人的一些心得、项目什么的。LeetCode和牛客网就主要在里面刷算法题，看论坛里别人的算法，我自己也是在github上推送自己的博客，记录一些知识点。

​	

