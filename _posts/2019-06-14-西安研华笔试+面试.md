---
title: 西安研华笔试+面试
layout: post
categories: 求职
---
## 2019.6.14 西安研华笔试+面试

### 一、笔试题

**1.接口与抽象类的区别？**

| 参数           | 抽象类                                                       | 接口                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 默认的方法实现 | 它可以有默认的方法实现                                       | 接口完全是抽象的。它根本不存在方法的实现                     |
| 实现           | 子类使用**extends**关键字来继承抽象类。如果之类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。 |
| 构造器         | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 访问修饰符     | 抽象方法可以有**public**、**protected**和**default**这些修饰符 | 接口方法默认修饰符是**public**。不可以使用其它修饰符         |
| main方法       | 抽象方法可以有main方法并且我们可以运行它                     | 接口没有main方法，因此我们不能运行它。                       |
| 多继承         | 抽象类可以继承一个类或实现多个接口                           | 接口只可以继承一个或多个其他接口                             |
| 速度           | 它比接口的速度要快                                           | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。   |
| 添加新方法     | 如果要往抽象类中添加新的方法，可以给他提供默认的实现。因此不需要改变现在的代码。 | 如果要往接口中添加方法，那么必须改变实现该接口的类。         |

**2.什么是JDBC？**

>JDBC代表Java数据库连接(**J**ava **D**ata**b**ase **C**onnectivity)，它是用于Java编程语言和数据库之间的数据库无关连接的标准Java API，换句话说：JDBC是用于在Java语言编程中与数据库连接的API。

**3.给一个try{}catch{}finally{}的程序题，写出其输出结果**

**4.HTTP请求在SpringMVC里的处理过程**

这个好可惜，自己有学过这块内容，但是脑子里只能模糊的记忆着。

> 在SpringMVC的http请求处理过程中，包括了前端控制器（DispatcherServlet）、处理映射器(HandlerMapping)、处理适配器(HandlerAdapter)、处理器((Handler)Controller)、视图解析器(ViewReslover)、视图(View)这六大主要对象。

![](F:\desk\md\Typora\images\处理过程.jpg)

### 二、面试题

（顺序可能不太对）

**1.数据库多表的连接有哪些？**

> 我首先说了可以让两张表里相同的字段直接用 = 连接，然后又说了左连接left join on，右连接right join on，等值连接join on。 

**2.Java高并发有哪些解决高并发的方法？volatile类型变量有什么作用？**

我先说了volatile和synchronized，面试官继续问volatile变量有什么作用？

心里大概清楚volatile的作用，但是因为时间长了忘了原子性和可见性这两个名词，然后就没答出来。。。

> volatile变量提供顺序和可见性保证，例如JVM或JIT为了获得更好的性能会对语句进行重排序，但是volatile类型变量即使在没有同步快的情况下赋值，也不会与其他语句进行重排序。volatile提供happens-before的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile还能提供原子性，如读64位数据类型，像long和double都不是圆桌子的，但volatile类型的double和long就是原子的。

**3.Java是怎样释放一个对象的？**

> 我说的是，可以让这个对象的引用直接等null，当该对象不存在引用后，依靠JVM的垃圾自动回收机制，进行回收。
>
> 可能是我第一问的回答不是他想要的答案。

**又问Java怎样立即释放一个对象？**

> 我emmm....，这个还真没有了解过。

> Java定义了一个特殊的方法叫做finalize()，它提供了C++析构函数的一些功能。但是，finalize()并不完全与C++的析构函数一样，并可以假设它会导致一系列的问题。finalize()方法作用的一个关键元素是Java的垃圾回收器。
>
> 在Java中，当你创建 一个对象时，Java虚拟机（JVM）为该对象分配内存、调用析构函数并开始跟踪你使用的对象。当你停止使用一个对象（也就是说，当没有对该对象的有效引用时），JVM通过垃圾回收器将该对象标记为释放这状态。
>
> finalize方法是在Object类中定义的，因此所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作，finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。

**4.各学科成绩（数据结构、算法、计算机网络）**

略~

**5.计算机网络的体系结构？各层有什么作用？**

> 因为长时间没有看计算机网络方面的知识，所以只说了五层协议每一层的名字。

> 1.应用层的任务是通过应用进程间的交互来完成特定网络应用。
>
> 2.运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。
>
> > 运输层主要使用以下两种协议：
> >
> > (1)传输控制协议TCP，提供面向连接的，可靠的数据传输服务。
> >
> > (2)用户数据协议UDP，提供无连接的，尽最大努力的数据传输服务(不保证数据传输的可靠性)。
>
> 3.网络层负责为分组交换网上的不同主机提供通信服务。
>
> 4.数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧。
>
> 5.物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。
>

**6.问项目经验**

> 我讲了最近做的课设，前端使用了JQuery+AJAX，后端使用了SSM框架集。

**MyBatis与Spring Data、Hibernate的区别。**

(当时问了与Spring的区别，不知道啥意思，我讲了与Hibernate的区别，下面才了解了是SpringData = =)

> 我说，Hibernate是一个傻瓜式的框架，它的使用很方便，但是一个很简单的语句经过它处理，可能需要很复杂的处理过程。而MyBatis虽然写配置文件的时候可能有些麻烦，但是处理效率很高。(应该是讲错了。。。)
>
> 它们的区别见另一位博文https://www.cnblogs.com/liaojie970/p/7743068.html
> 

**7.双端队列的插入手写代码，不行的话说清思路**

> 非常糟糕，一时大脑一片空白，之前只是简单知道双端队列的功能，却不知道具体的实现。。。下来看了下才发现，好简单。。。

> 头插入：首先创建一个临时指针指向头节点，然后让头指针指向加入进来的节点，如果队列开始为空，则让尾指针也指向加入进来的节点；如果队列不为空，那么让原头节点的prev指针指向新加入进来的节点即可，最后链表大小+1。

```java
//LinkedList源码
public void addFirst(E e) {
    linkFirst(e);
}
private void linkFirst(E e) {
    final Node<E> f = first;
    final Node<E> newNode = new Node<>(null, e, f);
    first = newNode;
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    size++;
    modCount++;
}

/**
     * Links e as last element.
     */
void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}

```

**8.servlet是单例还是多例？为什么？怎样来判断它是单例还是多例？**

> 想了十几秒钟，说了是单例的。面试官看我停顿这么长时间就继续细问了后面两个问题。
>
> 因为如果是多例的，那么每有一个请求都必须创建一个servlet，这样当请求多的时候，会占用很多资源。
>
> 可以在serlvet里添加一个静态变量，在它的构造方法里进行自增打印，来看构造器调用了几次。

**9.前端到数据库的数据传输是怎样的？**

> 我说，前端发送GET或POST请求，到Servlet，servlet调用service层方法，service层调用dao层方法访问数据库，连接数据库用JDBC。。。


**10.GET和POST请求的区别。**

> 我说，使用GET请求，发送的数据会在地址栏里显示，使用POST请求，发送的数据不会再地址栏显示。回答了些皮毛。。。除了我回答的一点，还有：
>
> 1.GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&俩捏。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后在传输。POST请求会把请求的数据放置在HTTP请求体里。因此GET请求的数据会暴露在地址栏里，而POST请求则不会，而是在请求体里。
>
> 2.传输数据的大小
>
> 由于特定浏览器和服务器对URL的长度有限制，因此，发送GET请求时，传输数据会受到URL长度的限制。
>
> 对于POST请求，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST请求提交数据大小进行限制。
>
> 3.POST请求的安全性比GET更高。

**11.课设有没有写登陆？登陆信息怎么保存的？**

> 我说，有，我目前是保存在session中的，当然也可以保存在cookie里。

**技术面试结束，后面又和项目主管面试，问的不是技术问题，但是二面自我感觉不好。**

项目主管上来就问我，你现在是大三，后面考研不？	不。

那你为啥不考研？	我不想学习了。。。

Oh My God!	蹦出了自己心底的真实想法（手动滑稽）。

这样就开始了不在状态的面试。。。

讲清了为啥不考研后，让我做自我介绍，主要从以下方面：

> 自己擅长的地方，以后主要学习什么语言，希望在公司得到哪些提高（具体）？
>
> 自己的优点和缺点？
> 
> 期间还询问了我一些其他方面的事情，感觉很多地方回答的不好。